# -*- coding: utf-8 -*-
"""Project2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IG3D78f_ekOGy42_V7GQ4SewZIY4XG-x
"""

# libraries and data
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from collections import defaultdict
import sys

with open("ccode_samples7", "r") as file1:
    samples = [float(i) for line in file1 for i in line.split(',') if i.strip()]

with open("ccode_data7", "r") as file1:
    databits = [float(i) for line in file1 for i in line.split(',') if i.strip()]

samples = np.array(samples)

# constants

memlen = 2;
memlenp1 = memlen + 1;
ratio = 3;
SNUM = 2 ** memlen
ENUM = 2 * SNUM;
BNUM = len(databits)
hard_decode = 1
soft_decode = 2

# Custom methods

def decimalToBinary(n):
    return [int(x) for x in list('{0:02b}'.format(int(n)))]

def decimalToBinary_3(n):
  return [int(x) for x in list('{0:03b}'.format(int(n)))]


def generateOutputBits(encoderState):
  # encoderState is a state in binary
  # convert to an array
  ar = np.array(encoderState)

  # generate output bits for this encoder
  new_ar = []
  x2 = (ar[2] + ar[1] + ar[0]) % 2
  x1 = (ar[2] + ar[0]) % 2
  x0 = (ar[2] + ar[1]) % 2
  new_ar.append(x2)
  new_ar.append(x1)
  new_ar.append(x0)
  #print(' generateOutputBits ', len(new_ar))
  return new_ar

def listToString(lst):
  st = ''.join(str(e) for e in lst)
  #print(' listToString ',len(st))
  return st


def getNumericArrayOf(st):
  num_ar = [int(numeric_str) for numeric_str in st]
  return num_ar



def find_hamming_dist(A, B):
  dist = 0
  for i in range(0, max(len(A), len(B))):
    if(A[i] != B[i]):
      dist += 1

  return dist



def getOutputBits(state):
  bin_state_ = decimalToBinary_3(state)
  output_code = generateOutputBits(bin_state_)
  return output_code

def saveToTransitionMatrix(bin_state, new_st, output_code, input_bit):
  transition_matrix[listToString(bin_state), listToString(decimalToBinary(new_st))] = listToString(output_code)
  transition_bits[listToString(bin_state), listToString(decimalToBinary(new_st))] = input_bit

def getNewStateFrom(state):
  return state % (2 ** memlen) 

def getWholeState(cur_state, bit):
  cur_state = cur_state << 1
  cur_state = cur_state | bit
  return cur_state

def addToOutputList (all_outputs, output_code):
  if listToString(output_code) not in all_outputs:
    all_outputs.append(listToString(output_code))
  return all_outputs


def addToChildStatesList (child_states_list, bin_state, new_st):
  if listToString(bin_state) not in child_states_list:
      child_states_list[listToString(bin_state)] = []
  child_states_list[listToString(bin_state)].append(listToString(decimalToBinary(new_st)))
  return child_states_list

  
def addToParentStatesList(parent_states_list, bin_state, new_st):
  if listToString(decimalToBinary(new_st)) not in parent_states_list:
      parent_states_list[listToString(decimalToBinary(new_st))] = []
  parent_states_list[listToString(decimalToBinary(new_st))].append(listToString(bin_state))
  return parent_states_list


def addToStateList(states, bin_state, new_st):
  if listToString(bin_state) not in states:
    states.append(listToString(bin_state)) 
  if listToString(decimalToBinary(new_st)) not in states:
    states.append(listToString(decimalToBinary(new_st)))
  return states



"""#######   BUILD THE TRANSITION MATRIX   ########


"""

# This dictionary will hold the output of old_state to new_state; transition_matrix[old_state][new_state] = output_bits
transition_matrix = {}
transition_bits = {}
states = []
all_outputs = []
child_states_list = {}
parent_states_list = {}

for i in range(0, SNUM):
  cur_state = i
  bin_state = decimalToBinary(cur_state)

  for bit in range(0,2):
    # find the next states when input bit is 0, or 1 
    modified_state = getWholeState(cur_state, bit)
    new_st = getNewStateFrom(modified_state)

    # generate output code for this case when input is 0
    output_code = getOutputBits(modified_state)
    #print('cur_state = ', listToString(decimalToBinary(cur_state)) , ' input = 0  ',' output_code = ', output_code, 'new_st = ', listToString(decimalToBinary(new_st)) )

    # save to transition matrix
    saveToTransitionMatrix(bin_state, new_st, output_code, bit)

    # save all values
    all_outputs = addToOutputList (all_outputs, output_code)
    child_states_list = addToChildStatesList (child_states_list, bin_state, new_st)
    parent_states_list = addToParentStatesList(parent_states_list, bin_state, new_st)
    states = addToStateList(states, bin_state, new_st)
  
# print(transition_matrix)
# print(transition_bits)
# print(child_states_list)
# print(parent_states_list)
# print(all_outputs)
# print(states)

########## COST ############

threshold = ratio * BNUM + 1

def getCostOfStates(states):
  cost_of_states = {}
  cost_of_parent_states = {}
  for st in states:
    if st not in cost_of_states:

      # initialize the 00 state as active
      flag = 0
      for s in st:
        if s == '1':
          flag = 1
      if flag == 0:
        cost_of_states[st] = 0.0
      else:
        cost_of_states[st] = threshold

  cost_of_parent_states = cost_of_states.copy()
  #print('getCostOfStates ', cost_of_states)

  return cost_of_states, cost_of_parent_states

"""### Hard Coding ###"""

def getReceivedBitsWithHardCoding(samples):
  # Taking all the samples and defining them either 0 or 1 [Hard Decoding]
  current_received_bits = np.zeros(len(samples))
  i = 0
  for i in range(0,len(samples)):
    if samples[i] > 0:
      current_received_bits[i] = 1
    else:
      current_received_bits[i] = 0;

  return current_received_bits

"""### Soft Coding ###"""

def getReceivedBitsWithSoftCoding(samples):
  # Taking all the samples and defining them either 0 or 1 [Hard Decoding]
  current_received_bits = np.zeros(len(samples))
  i = 0
  for i in range(0,len(samples)):
    if samples[i] > 0:
      current_received_bits[i] = 1
    else:
      current_received_bits[i] = 0;

  return current_received_bits

def get_possible_transition(cost_of_states, child_states_list, threshold):
  # Find out all the transitions that is possible from each states to child states
  state_transition_flag = {}
  for j in range(0, len(states)):
    now_state = states[j]
    if (cost_of_states[now_state] < threshold):
      child_states = child_states_list[now_state]
      #print(child_states)
      for k in range(0, len(child_states)):
        state_transition_flag[(now_state, child_states[k])] = 1
  return state_transition_flag

def isKeyPresent(parent_state, now_state, state_transition_flag):
  key_to_lookup = (parent_state, now_state)
  if key_to_lookup in state_transition_flag:
    return True
  else:
    return False

def get_output_bits_ar(parent_state, now_state, transition_matrix):
  output = transition_matrix[(parent_state, now_state)]
  #print(output)
  output_bits_ar = getNumericArrayOf(output)
  return output_bits_ar

def addInputBitToPath(selectedpath, input_bit):
  if (now_state not in selectedpath):
    selectedpath[now_state] = []
  else: 
    selectedpath[now_state].append(input_bit)
  return selectedpath


def displayOutput(states, cost_of_states, selectedpath, samples, step, decoding_type):

  print('step ', step + 1, ' -- samples: [', end='')
  for i in range(0, len(samples)):
    print(sample_values[i], end='')
    if(i < len(sample_values) - 1):
      print(',', end='')
    else:
      print('];', end='')
  print(' cost: [',end='')
  for cst in range(0, SNUM):
    now_state = states[cst]
    if (decoding_type == hard_decode):
      print(cost_of_states[now_state], end='')
      
    if (decoding_type == soft_decode):
      print(cost_of_states[now_state]/2, end='')

    if(cst < SNUM - 1):
      print(',', end='')
  print(']')
        
  for j in range(0, SNUM):
    print('S',j, ':', end = '')
    now_state = states[j]
    #print(selectedpath[now_state], end = '')
    st = selectedpath[now_state]
    l = len(st)
    for k in range(0, l):
      if (k < l-1 ):
        print(st[k],end='')
      else:
        print(st[k])


def displayOutputToFile(states, cost_of_states, selectedpath, samples, step, decoding_type, file_name):
  
  file = open(file_name, "a")
  file.write('step ' + str((step + 1)) + ': ')

  file.write(' cost: [')
  for cst in range(0, SNUM):
    now_state = states[cst]

    if (decoding_type == hard_decode):
      file.write(str(int(cost_of_states[now_state])))
    
    if (decoding_type == soft_decode):
      val = "{:e}".format((cost_of_states[now_state]/2))
      file.write(str(val))

    if(cst < SNUM - 1):
      file.write(',')
  file.write(']\n')
        
  for j in range(0, SNUM):
    file.write('S' + str(j) + ':')
    now_state = states[j]
    #print(selectedpath[now_state], end = '')
    st = selectedpath[now_state]
    l = len(st)
    for k in range(0, l):
      if (k < l-1 ):
        file.write(str(st[k]))
      else:
        file.write(str(st[k]) + '\n')

  file.write('\n')





def saveToFile(states, selectedpath, cost_of_states, file_name):

  min_cost = sys.float_info.max
  min_state = ''
  for i in range(0, len(states)):
    now_state = states[i]
    if (cost_of_states[now_state] < min_cost):
      min_cost = cost_of_states[now_state]
      min_state = now_state
  
  selected_state_path = selectedpath[min_state]
  file = open(file_name, "a")

  for i in range(0, len(selected_state_path)):
    file.writelines(str(selected_state_path[i]) + '\n')

  file.close()

"""##### SIMULATING VITERBI DECODING - Hard Decoding ###########


"""

#BNUM = 2 # testing for only 2

# initially we are in time step 0
# and initially we start from state 0. We have four states, they are 00, 01, 10, 11
# we apply 0, 1 as input, as a result we will get 2 outputs and will transition to 2 next states with 2 additional cost
# j is time step

cost_of_states, cost_of_parent_states = getCostOfStates(states)
current_received_bits = getReceivedBitsWithHardCoding(samples)


selectedpath = {}

for i in range(0, SNUM):
  now_state = states[i]
  selectedpath[now_state] = []

prevSelectedPath = selectedpath.copy() 

for i in range(0, BNUM):
    thisrcv = np.zeros(ratio)
    thisrcv = current_received_bits[i*ratio:(i+1)*ratio]
    sample_values = samples[i*ratio:(i+1)*ratio]
    #print(thisrcv)


    state_transition_flag = get_possible_transition(cost_of_states, child_states_list, threshold )

    # Update the cost of each states after finding the possible transitions
    for j in range(0, len(states)):
      now_state = states[j]
      parent_states = parent_states_list[now_state]
      min_cost = BNUM * ratio + 1
      min_input_bit = -1
      min_path = []

      for p in range(0, len(parent_states)):
        prev_state = parent_states[p]
        is_there_transition = isKeyPresent(prev_state, now_state, state_transition_flag)
        if (is_there_transition == True):
          output_bits_ar = get_output_bits_ar(prev_state, now_state, transition_matrix)
          cost = find_hamming_dist(thisrcv, output_bits_ar)
          cumulating_cost = (cost_of_parent_states[prev_state] + cost)
          if (min_cost > cumulating_cost):
            min_cost = cumulating_cost
            min_input_bit = transition_bits[prev_state,now_state]
            min_path = prevSelectedPath[prev_state]

      cost_of_states[now_state] = min_cost
      # selectedpath = addInputBitToPath(selectedpath, min_input_bit)
      selectedpath[now_state] = min_path + [min_input_bit]

    cost_of_parent_states = cost_of_states.copy()
    prevSelectedPath = selectedpath.copy() 
    #displayOutput(states,cost_of_states, selectedpath, sample_values, i, hard_decode)
    displayOutputToFile(states,cost_of_states, selectedpath, sample_values, i, hard_decode, "hd7")
    saveToFile(states, selectedpath, cost_of_states, "hd7_data")



"""# Soft decoding #"""

def find_dist(thisrcv, output_bits_ar):
  new_ar = []
  for i in range(0, len(output_bits_ar)):
    if (output_bits_ar[i] == 0):
      new_ar.append(-1)
    if (output_bits_ar[i] == 1):
      new_ar.append(1)

  sum = 0.0
  for i in range(0, len(new_ar)):
    sum += (abs(new_ar[i] - thisrcv[i])) ** 2
  return sum



# ans = find_dist([0.01, -1, 0.01], [0,0,0])
# com = ((1.01)**2 + 0 + (1.01)**2)
# print(ans, com)

#BNUM = 2 # testing for only 2

# initially we are in time step 0
# and initially we start from state 0. We have four states, they are 00, 01, 10, 11
# we apply 0, 1 as input, as a result we will get 2 outputs and will transition to 2 next states with 2 additional cost
# j is time step

cost_of_states, cost_of_parent_states = getCostOfStates(states)
#current_received_bits = getReceivedBitsWithHardCoding(samples)

selectedpath = {}

for i in range(0, SNUM):
  now_state = states[i]
  selectedpath[now_state] = []

prevSelectedPath = selectedpath.copy() 

for i in range(0, BNUM):
    thisrcv = np.zeros(ratio)
    #thisrcv = current_received_bits[i*ratio:(i+1)*ratio]
    thisrcv = samples[i*ratio:(i+1)*ratio]
    #print(thisrcv)


    state_transition_flag = get_possible_transition(cost_of_states, child_states_list, threshold )

    # Update the cost of each states after finding the possible transitions
    for j in range(0, len(states)):
      now_state = states[j]
      parent_states = parent_states_list[now_state]
      min_cost = sys.float_info.max
      min_input_bit = -1
      min_path = []

      for p in range(0, len(parent_states)):
        prev_state = parent_states[p]
        is_there_transition = isKeyPresent(prev_state, now_state, state_transition_flag)
        if (is_there_transition == True):
          output_bits_ar = get_output_bits_ar(prev_state, now_state, transition_matrix)
          cost = find_dist(thisrcv, output_bits_ar)
          cumulating_cost = (cost_of_parent_states[prev_state] + cost)
          if (min_cost > cumulating_cost):
            min_cost = cumulating_cost
            min_input_bit = transition_bits[prev_state,now_state]
            min_path = prevSelectedPath[prev_state]

      cost_of_states[now_state] = min_cost
      # selectedpath = addInputBitToPath(selectedpath, min_input_bit)
      selectedpath[now_state] = min_path + [min_input_bit]

    cost_of_parent_states = cost_of_states.copy()
    prevSelectedPath = selectedpath.copy() 
    #displayOutput(states,cost_of_states, selectedpath, sample_values, i, soft_decode)
    displayOutputToFile(states,cost_of_states, selectedpath, sample_values, i, soft_decode, "sd7")
    saveToFile(states, selectedpath, cost_of_states, "sd7_data")

